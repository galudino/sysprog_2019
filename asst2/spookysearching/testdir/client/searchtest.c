/**
 *  @file       searchtest.c
 *  @brief      Client source file for Asst2: Spooky Search
 *
 *  @author     Gemuele Aludino
 *  @date       04 Nov 2019
 *  @copyright  Copyright © 2019 Gemuele Aludino
 */
/**
 *  Copyright © 2019 Gemuele Aludino
 *
 *  Permission is hereby granted, free of charge, to any person obtaining
 *  a copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included
 *  in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 *  OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 *  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 *  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 *  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
 *  THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#define _POSIX_C_SOURCE 199390L

#include <unistd.h>
#include <time.h>
#include <math.h>

#include "header.h"
#include "multitest.h"

/**
 *  @brief Creates an array of size capacity, with search partitions of size subcapacity, and conducts a search for a integer, key -- and runs the search iterations times using test_case
 * 
 *  @param[in]  searchfunc  linear search function
 *  @param[in]  capacity    desired array capacity
 *  @param[in]  subcapacity desired subcapacity for search
 *  @param[in]  key         key to search for
 *  @param[in]  iterations  quantity of iterations
 */
void test_set(int32_t (*searchfunc)(int32_t *, size_t, int32_t, int32_t),      
              size_t capacity, 
              int32_t subcapacity, 
              int32_t key, 
              int32_t iterations);

/**
 *  @brief Runs searchfunc, iteration times, using the array generated by test_set, to search for a key
 * 
 *  @param[in]  searchfunc  linear search function
 *  @param[in]  capacity    desired array capacity
 *  @param[in]  subcapacity desired subcapacity for search
 *  @param[in]  key         key to search for
 *  @param[in]  iterations  quantity of iterations
 */
void test_case(int32_t (*searchfunc)(int32_t *, size_t, int32_t, int32_t),
               int32_t *base,
               size_t capacity,
               int32_t subcapacity,
               int32_t key,
               int32_t iterations);

/**
 *  @brief  Program execution begins here
 *
 *  @param[in]  argc    argument count
 *  @param[in]  argv    command line arguments
 *
 *  @return     exit status
 */
int main(int argc, const char *argv[]) {
    srand(time(NULL));

    printf("\n(array size / partition size / proc-thread count)\n\n");

    /* control - single process */
    printf("Test C0_0\n");
    test_set(lsearch_int32_control, 500, 500, 99, 100);

    printf("Test C0_1\n");
    test_set(lsearch_int32_control, 5000, 5000, 99, 100);

    printf("Test C0_2\n");
    test_set(lsearch_int32_control, 10000, 10000, 99, 100);

    printf("Test C0_3\n");
    test_set(lsearch_int32_control, 20000, 20000, 99, 100);

    printf("Test C0_4\n");
    test_set(lsearch_int32_control, 25000, 25000, 99, 100);

    printf("Test P0_0\n");
    test_set(lsearch_int32, 500, 25, 99, 100);

    printf("Test P0_1\n");
    test_set(lsearch_int32, 5000, 25, 99, 100);

    printf("Test P0_2\n");
    test_set(lsearch_int32, 10000, 25, 99, 100);

    printf("Test P0_3\n");
    test_set(lsearch_int32, 20000, 25, 99, 100);

    printf("Test P0_4\n");
    test_set(lsearch_int32, 25000, 25, 99, 100);

    printf("Test P1_0\n");
    test_set(lsearch_int32, 500, 50, 99, 100);

    printf("Test P1_1\n");
    test_set(lsearch_int32, 5000, 50, 99, 100);

    printf("Test P1_2\n");
    test_set(lsearch_int32, 10000, 50, 99, 100);

    printf("Test P1_3\n");
    test_set(lsearch_int32, 20000, 50, 99, 100);

    printf("Test P1_4\n");
    test_set(lsearch_int32, 25000, 50, 99, 100);

    printf("Test P2_0\n");
    test_set(lsearch_int32, 500, 125, 99, 100);

    printf("Test P2_1\n");
    test_set(lsearch_int32, 5000, 125, 99, 100);

    printf("Test P2_2\n");
    test_set(lsearch_int32, 10000, 125, 99, 100);

    printf("Test P2_3\n");
    test_set(lsearch_int32, 20000, 125, 99, 100);

    printf("Test P2_4\n");
    test_set(lsearch_int32, 25000, 125, 99, 100);

    printf("Test P3_0\n");
    test_set(lsearch_int32, 500, 250, 99, 100);

    printf("Test P3_1\n");
    test_set(lsearch_int32, 5000, 250, 99, 100);

    printf("Test P3_2\n");
    test_set(lsearch_int32, 10000, 250, 99, 100);

    printf("Test P3_3\n");
    test_set(lsearch_int32, 20000, 250, 99, 100);

    printf("Test P3_4\n");
    test_set(lsearch_int32, 25000, 250, 99, 100);

    return EXIT_SUCCESS;
}

void test_set(int32_t (*searchfunc)(int32_t *, size_t, int32_t, int32_t),      
              size_t capacity, 
              int32_t subcapacity, 
              int32_t key, 
              int32_t iterations) {
    int32_t *base = NULL;

    int32_t r0 = 0;
    int32_t r1 = 0;
    int32_t temp = 0;

    int32_t i = 0;

    srand(time(NULL));

    {
        base = calloc(capacity, sizeof *base);
        assert(base);
    }

    {
        for (i = 0; i < capacity; i++) {
            base[i] = i;
        }
    }

    {
        for (i = 0; i < capacity - 1; i++) {
            r0 = randrnge(0, capacity);
            r1 = randrnge(0, capacity);

            while (r0 == r1) {
                r0 = randrnge(0, capacity);
            }

            temp = base[r0];

            base[r0] = base[r1];
            base[r1] = temp;
        }
    }    

    printf("- test parameters -\narray capacity: %lu\narray partition size: %d\narray search key: %d\niteration count: %d\n\n", capacity, subcapacity, key, iterations);
    test_case(searchfunc, base, capacity, subcapacity, key, iterations);
    printf("- end of test -\n\n");

    free(base);
    base = NULL;
    
}

void test_case(int32_t (*searchfunc)(int32_t *, size_t, int32_t, int32_t),
               int32_t *base,
               size_t capacity,
               int32_t subcapacity,
               int32_t key,
               int32_t iterations) {
    int32_t r0 = 0;
    int32_t temp = 0;
    int32_t result = -1;
    int32_t i = 0;

    struct timespec x = { 0.0, 0.0 };
    struct timespec y = { 0.0, 0.0 };

    double total_ns = 0.0;
    double elapsed_ns_avg = 0.0;
    double time_min = 0.0;
    double time_max = 0.0;
    double time_this = 0.0;
    double std_deviation = 0.0;

    double *results = NULL;

    results = calloc(iterations, sizeof *results);
    assert(results);

    for (i = 0; i < iterations; i++) {
        results[i] = 0.0;
    }

    /* test case time start */

    for (i = 0; i < iterations; i++) {
        printf("test iteration: %d\n", i);

        result = result > -1 ? result : capacity - 1;

        {
            do {
                temp = base[result];

                r0 = randrnge(0, capacity);

                base[result] = base[r0];
                base[r0] = temp;
            } while (result == r0);
        }

        clock_gettime(CLOCK_REALTIME, &x);
        result = searchfunc(base, capacity, subcapacity, key);
        clock_gettime(CLOCK_REALTIME, &y);

        time_this = elapsed_time_ns(x, y);

        time_max = time_this > time_max ? time_this : time_max;
        time_min = time_this < time_min ? time_this : time_min;

        total_ns += time_this;

        results[i] = time_this;

        if (time_min == 0.0) {
            time_min = time_this;
        }

        if (time_max == 0.0) {
            time_max = time_this;
        }

        time_min = time_this < time_max ? time_this : time_max;
        time_max = time_this > time_max ? time_this : time_max;

        if (result <= -1) {
            printf("returned index: %d (not found)\nsearch failed\n------------\n", result);
        } else {
            printf("returned index: %d (was found)\nsearch successful\n------------\n", result);
        }
    }

    /* test case time end */

    elapsed_ns_avg = mean(results, iterations);
    std_deviation = standard_deviation(results, iterations);

    fprintf(stdout, "%s: %f %s\n%s: %f %s\n%s: %f %s\n%s: %f %s\n\n", "min",  convert_ns_to_mcs(time_min), MCS, "max", convert_ns_to_mcs(time_max), MCS, "avg", convert_ns_to_mcs(elapsed_ns_avg), MCS, "stddev", convert_ns_to_mcs(std_deviation), MCS);

    free(results);
    results = NULL;
}
